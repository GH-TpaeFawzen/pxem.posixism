#!/bin/sh

# pxemx.posixism. Execute compiled Pxem program.
# Written by TpaeFawzen.
# License. CC0.

set -eu # -e is for syntax error
umask 0022
export LC_ALL=C
type getconf >/dev/null 2>&1 &&
type command >/dev/null 2>&1 &&
export PATH="$(command -p getconf PATH)${PATH+:}${PATH-}"
export UNIX_STD=2003 # for HP-UX
export POSIXLY_CORRECT=1 # for GNU utils, bash, pdksh
case "${BASH_VERSION:+y}" in (y)
  set -o posix
  set +B # disable echo {a,s,d} to be echo a s d
;;esac
case "${ZSH_VERSION:+y}" in (y)
  emulate sh
  setopt shwordsplit
  alias -g '${1+"$@"}'='"$@"'
  NULLCMD=:
;;esac
# reject svr2 bourne
case "$(
  ( set dummy; shift; set dummy "$@"; shift; echo $# )
)" in (1)
  printf %s\\n "${0##*/}: Please use newer POSIX-compatible shell."
  exit 1
;;esac
# reject svr4 bourne
eval "! false" || {
  printf %s\\n "${0##*/}: Please use newer POSIX-compatible shell."
  exit 1
}

usagex(){
  printf %s\\n "Usage: ${0##*/} FILE" 1>&2
  exit 1
}

case "$# ${1:+$1}" in ('1 -?'|'1 -h'|'1 --help')
  usagex
;;esac
while case "$#" in (0) ! :;; (*) :;; esac; do
  case "$1" in (--) shift; break;; esac
  case "$1" in (-*) usagex;; esac
  break
done
case "$#" in ([!1]*|1?*) usagex;; esac

errorx(){
  printf %s\\n "${0##*/}: $2"
  exit $1
}
case "$1" in ('')
  errorx 1 'Filename cannot be empty'
;;(-*)
  set -- "./$1"
;;esac

# main

# load subprogram
(
  awk \
    -v flushat="$(
      echo $(( \
        $(getconf ARG_MAX 2>&1 || echo 2048) \
        - 9 \
      ))
    )" \
    -v getter="head -n1|od -An -vtu1|tr -Cs 0123456789 '[ *]'|grep .|sed -e 's/^ *//' -e 's/ *$//'" \
    -v randseed="$(
      test -c /dev/urandom && test -r /dev/urandom && {
        od -A n -t d4 -N 4 -v /dev/urandom |
        tr -Cd 0123456789-
      } || {
        (ps -Ao pid,etime,pcpu,vsz; date) |
        od -A n -t u4 -v |
        tr -Cs 0123456789 '[\n*]' |
        grep . |
        tail -n 42 |
        sed '
          1i\
''''''''''-2147483648
          s/.*\(.\{8\}\)$/\1/
        ' |
        awk -v a=0 '
          {a+=$0;}
          END{print a;}
        '
      }
    )" \
    -f "$1" ||
  echo 'error 2 load failed'
) | 
grep . |
# parse output
# one of these:
# /^-?[0-9]+$/, /^error [0-9]+ .*$/, /^flush$/
awk \
  -v maxlen="$(
    echo $(( \
      $(getconf ARG_MAX 2>&1 || echo 2048) \
      - 9 \
    ))
  )" \
  -v header="printf '" \
  -v footer="'" \
  -v errftr="' 1>&2" \
'
BEGIN{
  ORS="";
  LF=sprintf("\n");
  during_output=0;
}
/^flush$/{
  if(during_output==1)
    print footer LF;
  during_output=0;
  next;
}
/^error/{
  if(during_output) print footer LF;
  during_output=0;
  print$3|"cat 1>&2";
  for(i=4;i<=NF;i++){
    print OFS $i|"cat 1>&2";
  }
  print LF|"cat 1>&2";
  printf "exit %u\n", $2;
  exit $2;
}
/^-?[0-9]+$/{
  if(!during_output){
    print header;
    during_output=1;
  }
  printf "\\%o",$0;
  next;
}
{
  # HOW?
  printf"wtf\n" | "cat 1>&2";
  exit 33;
}
END{
  if(during_output) print footer;
}
' |
# output (and error handling) here
sh -s
