#!/bin/sh

# pxemi.2.posixism. Pxem-to-awk compiler-interpreter.
# Written by TpaeFawzen.
# License. CC0.

set -eu # -e is for syntax error
umask 0022
export LC_ALL=C
type getconf >/dev/null 2>&1 &&
type command >/dev/null 2>&1 &&
export PATH="$(command -p getconf PATH)${PATH+:}${PATH-}"
export UNIX_STD=2003 # for HP-UX
export POSIXLY_CORRECT=1 # for GNU utils, bash, pdksh
case "${BASH_VERSION:+y}" in (y)
  set -o posix
  set +B # disable echo {a,s,d} to be echo a s d
;;esac
case "${ZSH_VERSION:+y}" in (y)
  emulate sh
  setopt shwordsplit
  alias -g '${1+"$@"}'='"$@"'
  NULLCMD=:
;;esac
# reject svr2 bourne
case "$(
  ( set dummy; shift; set dummy "$@"; shift; echo $# )
)" in (1)
  printf %s\\n "${0##*/}: Please use newer POSIX-compatible shell."
  exit 1
;;esac
# reject svr4 bourne
eval "! false" || {
  printf %s\\n "${0##*/}: Please use newer POSIX-compatible shell."
  exit 1
}

usagex(){
  printf %s\\n "Usage: ${0##*/} FILE" 1>&2
  exit 1
}

case "$# ${1:+$1}" in ('1 -?'|'1 -h'|'1 --help')
  usagex
;;esac
while case "$#" in (0) ! :;; (*) :;; esac; do
  case "$1" in (--) shift; break;; esac
  case "$1" in (-*) usagex;; esac
  break
done
case "$#" in ([!1]*|1?*) usagex;; esac

errorx(){
  printf %s\\n "${0##*/}: $2"
  exit $1
}
case "$1" in ('')
  errorx 1 'Filename cannot be empty'
;;(-*)
  set -- "./$1"
;;esac

# $1 should be fname.

# NOT main yet. SORRY POSIXists.

#
# optlv. variable.
# optimization level. in decimal non-negative integer.
#
# lv. description. 
# 0.  simplest compilation.
# 1.  remove deadcode from after of .d to EOF or end of loop.
#     in level 0 filename .d.w is rejected; level >=1 accepts it.
# 2.  remove commands that would be NOP when not enough items.
# 3.  calculate constant expr.
#
# maybe TODO.
#   remove loops that would never be executed.
#   do constant .v
#
optlv=99

#
# compile. filter function.
# usage.
#   printf "%s" ${FILE##*/}" | compile fname
#   cat "$FILE" | compile content
#
# stdout. 
#   AWK subprogram.
#
# required variables.
#   optlv. optimization level in >=0 integer. see above.
#
# resulting variable.
#   assembly. result of pseudo-assembly.
#   fname_cmds. used commands except .d command. describes required functions.
#   content_cmds. used commands. describes required functions.
#
compile(){

# dollar one represents mode. either fname or content.
# default. fname.
case "$#" in (0) set -- fname;; esac
case "$1" in (fname|content) :
;; echo 'Usage: compile {fname|content}' 1>&2; return 80
;;esac

# mktbl="$(
#   printf 'pPoOnNiI_cCsSvVfFeErRwWxXyYzZaAtTmMdD+-!$%%' |
#   od -A n -t u1 -v |
#   tr -Cs 0123456789 '[\n*]' |
#   grep . |
#   awk -v '
#     {printf"cmd\"%d\"=\"%c\";",$0,tolower(sprintf("%c",$0));}
#   '
# )"

assembly="$(

od -A n -t u1 -v |
tr -Cs 0123456789 '[\n*]' |
grep . |
awk -v dot=46 '
BEGIN{
   cmd["112"]="p";cmd["80"]="p";
   cmd["111"]="o";cmd["79"]="o";
   cmd["110"]="n";cmd["78"]="n";
   cmd["105"]="i";cmd["73"]="i";
   cmd["95"] ="_";
   cmd["99"] ="c";cmd["67"]="c";
   cmd["115"]="s";cmd["83"]="s";
   cmd["118"]="v";cmd["86"]="v";
   cmd["102"]="f";cmd["70"]="f";
   cmd["101"]="e";cmd["69"]="e";
   cmd["114"]="r";cmd["82"]="r";
   cmd["119"]="w";cmd["87"]="w";
   cmd["120"]="x";cmd["88"]="x";
   cmd["121"]="y";cmd["89"]="y";
   cmd["122"]="z";cmd["90"]="z";
   cmd["97"] ="a";cmd["65"]="a";
   cmd["116"]="t";cmd["84"]="t";
   cmd["109"]="m";cmd["77"]="m";
   cmd["100"]="d";cmd["68"]="d";
   cmd["43"] ="+";
   cmd["45"] ="-";
   cmd["33"] ="!";
   cmd["36"] ="$";
   cmd["37"] ="%";
   split("",stack,":");
   level=0;
   first=second="";
   for(;;){
      if(getline first<=0) break;
      if(getline second<=0) second="";
      
      # /\.[pPoO...]/
      if(second in cmd && first==dot){
         emitliterate();
         print cmd[second];
      }
      # /.\./
      else if(second==dot){
         while(second==dot){
            pushliterate(first);
            first=second;
            if(getline second<=0){
               pushliterate(first);
               emitliterate();
               exit 0;
            }
         }
         if(second in cmd){
            emitliterate();
            print cmd[second];
         }
      }
      else{
         pushliterate(first);
         pushliterate(second);
      }
   }
   emitliterate();
}
function pushliterate(c){
   if(c=="") return;
   stack[level]=c;
   level+=1;
}
function emitliterate(){
   # literate shall be pushed in reverse order
   if(level==0) return;
   printf "l";
   for(;level>0;level-=1)
      printf " " stack[level-1];
   print "";
}
' |
# check syntax
# opt1. remove deadcode (from .d to EOF or matching .a)
awk -v me="${0##*/}" -v optlv="$optlv" '
BEGIN{
   nest=0;
   while(getline>0){
      nest+=/[wxyz]/-/a/;
      if(nest<0){
         print me ": Syntax error: .a command without matching .[wxyz]" | "cat 1>&2";
         exit 1;
      }
      # add a hint please
      # wxyz: begin of what level?
      # a: end of what level?
      if(/[wxyza]/) $0=$0 " @ " (/a/?nest+1:nest);
      print $0;
      # opt1: remove deadcode
      if(optlv<=0) continue;
      if(/d/&&nest==0) exit 0;
      if(/d/){
         unignore_on=nest-1;
         while(nest>unignore_on){
            if(getline<=0){
               print me ": Syntax error: .[wxyz] command without matching .a" | "cat 1>&2";
               exit 1;
            }
            nest+=/[wxyz]/-/a/;
         }
         print "a";
      }
   }
   if(nest>0){
      print me ": Syntax error: .[wxyz] command without matching .a" | "cat 1>&2";
      exit 1;
   }
   exit 0;
}'
)" # check syntax and remove deadcode end

# opt2. remove commands that would be NOP when not enough items.
case "$(( optlv >= 2 ))" in (1)
assembly="$(

printf %s\\n "$assembly" |
# remove poncsvrt+-!$% if surely empty, 
# because they are NOP in such case
# obtw +-!$% requires >=2 items
awk \
  -v assumed_size=0 \
  -v surely="$(
    case "$1" in (filename)
      echo 1
    ;;(content)
      echo 0
    ;;esac
  )" \
  -v heap_used=0 '
/[poncsvrt+!$%-]/&&surely&&assumed_size==0{
   next;
}
/[+!$%-]/&&surely&&assumed_size==1{
   next;
}
/l/&&surely{
   assumed_size+=NF-1;
}
/p/{
   assumed_size=0;
   surely=1;
}
/[ons]/&&surely&&assumed_size>=1{
   assumed_size-=1;
}
/[i_]/&&surely{
   if(surely) assumed_size+=1;
}
/c/&&surely&&assumed_size>=1{
   assumed_size+=1;
}
/[fewxyza]/{
   surely=0;
}
/t/&&surely&&assumed_size>=1{
   assumed_size-=1;
   heap_used=1;
}
/m/&&surely&&heap_used{
   assumed_size+=1;
}
/[+!$%-]/&&surely&&assumed_size>=2{
   assumed_size-=1;
}
1;
'
)" # remove poncsvrt+-!$% if surely empty end

;;esac # opt2 end

# opt3. calculate constant expr.
case "$(( optlv >= 3 ))" in (1)

assembly="$(

printf %s\\n "$assembly" |
# calculate const expr
# they are literals with cs+-!$%
awk -v me="${0##*/}" '
BEGIN{
   # plz remember
   split("",prog,":");
   # prog size
   i=0;
}
{
   # store current code
   prog[i]=$0; i+=1;
   
   prev=prog[i-2];
}
prev~"l"&&/l/{
   # join two literal commands
   prog[i-2]=prev substr($0,3);
   i-=1;
   next;
}
prev~"^l [^ ]+"&&/c/{
   sub("[^ ]+$","& &",prog[i-2]);
   i-=1;
   next;
}
prev~"^l [^ ]+$"&&/s/{
   # just discard it when single literal
   i-=2;
   next;
}
prev~"l"&&/s/{
   sub(" [^ ]+$","",prog[i-2]);
   i-=1;
   next;
}
prev~"^l [^ ]+ [^ ]+"&&/[+!$%-]/{
   # arithmetic requires >=2 items
   # prevent zero-division
   if(/[$%]/&&prev~"( 0| 0 [^ ]+)$") next;
   
   # extract two nums on top
   x=y=prev;
   sub(" [^ ]+ [^ ]+$","",prev);
   sub("^.* ","",x);
   sub(" [^ ]+$","",y); sub("^.* ","",y);
   # make it sure: x>=y
   if(x<=y){
      _x=x; x=y; y=_x;
   }
   
   # finally
   if(/\+/) prog[i-2]=prev " " (x+y);
   if(/-/) prog[i-2]=prev " " (x-y);
   if(/!/) prog[i-2]=prev " " (x*y);
   if(/\$/) prog[i-2]=prev " " int(x/y);
   if(/%/) prog[i-2]=prev " " int(x%y);
   i-=1;
   next;
}
END{
   for(j=0;j<i;j++)
      print prog[j];
}
'
)" # constant reduction end

;;esac # opt3 end

# now optimization is done.

# this is to determine what functions to define.
used_cmds="$(
printf %s\\n "$assembly" |
cut -c 1 |
sort |
uniq |
tr -d \\n |
case "$1" in (fname) tr -d d ;;(content) cat ;;esac
)"
case "$1" in (fname)
  fname_cmds="$used_cmds"
;;         (content)
  content_cmds="$used_cmds"
;;esac

# remove hints for wxyza
assembly="$(
printf %s\\n "$assembly" |
sed 's/ @ .*$//'
)"

# finally translate to awk
printf %s\\n "$assembly" |
sed -n '
# l has some arguments
# P(char) is push.
/^l /{
  s///
  s/[^ ]*/P(&);/g
  s/ //g
  p
  b
}
# they are simple; to same named function.
/[poni_csvfertm]/s//&();/p
t
/[wxyz]/s//while(&()){/p
t
/a/s//}/p
t
'"$(
# d needs some branching
case "$1" in (fname)
  echo '/d/s//exit(0);/p'
;;(content)
  echo '/d/s//d();return;/p'
;;esaf
)"'
t
# arithmetics because function name restrictions
/+/s//add();/p
t
/-/s//sub();/p
t
/!/s//mul();/p
t
/\$/s//div();/p
t
/%/s//mod();/p
t
# should not reach here
s/.*/WTF("&");/p
' |
(
case "$1" in (fname)
  printf 'BEGIN{k=0;split("",S,":");split("",h,":");'
  cat
  printf 'exit(0);}'
;;(content)
  printf 'function e(aa){k++;S[k]=S[k-1];for(aa=0;aa<S[k];aa++)S[k,aa]=S[k-1,aa];'
  cat
  printf 'd();}'
;;esac
) |
tr -d \\n

} # compile()

#
# P(char) is push.
# E() returns if empty.
# J() returns if size >= 2.
# T() is top.
# X() is pop, with return of the value.
# k>=0. global. id of VM.
# S. global stack. [k] or [k,i] where
#   S[k] stores size
#   S[k,i] stores items. 0<=i<S[k].
# h[k]. global heap. empty or integer
# u(char) is putchar().
# G() is getchar().
# U(char) is ungetc().
# A(str) is abort().
#

# define functions required by commands
echo "$used_cmds" |
fold -w 1 |
sort |
uniq |
sed -n '
# skip l; P() is enough
/p/s//function p(i){while(!E())u(X());}/p
/o/s//function o(i){if(!E())u(X());}/p
/n/s//function n(i,x,d,l){if(!E()){x=X();l=length(x);for(i=1;i<=l;i++)u((d=substr(x,i,1))~"[0-9]"?d+48:45);}}/p
/i/s//function i(){P(G());}/p
/_/c\
function _(m,c,s,x){\
  m="._: Not a decimal integer input";c=G();s=1;for(;;){\
    if(47<c&&c<58)break;if(c~"4[35]"){\
      s=44-c;c=G();break;}\
    if((8<c&&c<14)+(c==32)){c=G();continue;}A(m);}\
  if((c<48)+(c>57))A(m);for(;47<c||c<58+;c=G())x=x (c-48);U(c);P(s*x);}
/c/s//function c(){if(!E())P(T());}/p
/s/s//function s(){if(!E())X();}/p
/v/s//function v(i,j,t){for(i=0,j=S[k]-1;i<j;i++,j--){t=S[k,i];S[k,i]=S[k,j];S[k,j]=t;}}/p
# skip f; somewhere
# skip e; is defined on: compile content
/r/c\
function r(){if(!E()){if(rposonly&&T()<=0)A(".r: Undefined against non-positive item");P(int(rand()*X()));}}
/w/s//function w(){return E()||(X()!=0);}/p
/x/s//function x(a,b){if(E())return 1;a=X();b=X();return a<b;}/p
/y/s//function y(a,b){if(E())return 1;a=X();b=X();return a>b;}/p
/z/s//function z(a,b){if(E())return 1;a=X();b=X();return a==b;}/p
# skip a; no function needed
/t/s//function t(){if(!E())h[k]=X();}/p
/m/s//function m(){if(k in h)P(h[k]);}/p
/d/s//function d(i,j){if(k in h)delete h[k];k--;for(i=0,j=S[k];i<S[k+1];i++,j++,S[k]++)S[k,j]=S[k+1,i];}/p
/+/s//function add(){if(J())P(X()+X());}/p
/-/s//function sub(y){if(J()){y=X()-X();y=y<0?-y:y;P(y);}}/p
/!/s//function mul(){if(J())P(X()*X());}/p
/\$/s!!function div(x,y){if(J()){x=X();y=X();if(x*y==0)A(".$: Zero-division");P(int(x>y?x/y:y/x))!p
/%/s!!function mod(x,y){if(J()){x=X();y=X();if(x*y==0)A(".$: Zero-division");P(int(x>y?x%y:y%x))!p
'
