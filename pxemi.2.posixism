#!/bin/sh

# pxemi.2.posixism. Pxem-to-awk compiler-interpreter.
# Written by TpaeFawzen.
# License. CC0.

set -eu # -e is for syntax error
umask 0022
export LC_ALL=C
type getconf >/dev/null 2>&1 &&
type command >/dev/null 2>&1 &&
export PATH="$(command -p getconf PATH)${PATH+:}${PATH-}"
export UNIX_STD=2003 # for HP-UX
export POSIXLY_CORRECT=1 # for GNU utils, bash, pdksh
case "${BASH_VERSION:+y}" in (y)
  set -o posix
  set +B # disable echo {a,s,d} to be echo a s d
;;esac
case "${ZSH_VERSION:+y}" in (y)
  emulate sh
  setopt shwordsplit
  alias -g '${1+"$@"}'='"$@"'
  NULLCMD=:
;;esac
# reject svr2 bourne
case "$(
  ( set dummy; shift; set dummy "$@"; shift; echo $# )
)" in (1)
  printf %s\\n "${0##*/}: Please use newer POSIX-compatible shell."
  exit 1
;;esac
# reject svr4 bourne
eval "! false" || {
  printf %s\\n "${0##*/}: Please use newer POSIX-compatible shell."
  exit 1
}

usagex(){
  printf %s\\n "Usage: ${0##*/} FILE" 1>&2
  exit 1
}

case "$# ${1:+$1}" in ('1 -?'|'1 -h'|'1 --help')
  usagex
;;esac
while case "$#" in (0) ! :;; (*) :;; esac; do
  case "$1" in (--) shift; break;; esac
  case "$1" in (-*) usagex;; esac
  break
done
case "$#" in ([!1]*|1?*) usagex;; esac

errorx(){
  printf %s\\n "${0##*/}: $2"
  exit $1
}
case "$1" in ('')
  errorx 1 'Filename cannot be empty'
;;(-*)
  set -- "./$1"
;;esac

# $1 should be fname.

# NOT main yet. SORRY POSIXists.

#
# optlv. variable.
# optimization level. in decimal non-negative integer.
#
# lv. description. 
# 0.  simplest compilation.
# 1.  remove deadcode from after of .d to EOF or end of loop.
#     in level 0 filename .d.w is rejected; level >=1 accepts it.
# 2.  remove commands that would be NOP when not enough items.
# 3.  calculate constant expr.
#
# maybe TODO.
#   remove loops that would never be executed.
#   do constant .v
#
optlv=99

#
# compile. filter function.
# usage.
#   printf "%s" ${FILE##*/}" | compile [fname]
#   cat "$FILE" | compile content
#
# stdout. 
#   AWK subprogram with an independent line of comment indicating used commands.
#
# required variables.
#   optlv. optimization level in >=0 integer. see above.
#
compile(){

# dollar one represents mode. either fname or content.
# default. fname.
case "$#" in (0) set -- fname;; esac
case "$1" in (fname|content) :
;;(*) echo 'Usage: compile {fname|content}' 1>&2; return 80
;;esac

assembly="$(

od -A n -t u1 -v |
tr -Cs 0123456789 '[\n*]' |
grep . |
# mktbl="$(
#   printf 'pPoOnNiI_cCsSvVfFeErRwWxXyYzZaAtTmMdD+-!$%%' |
#   od -A n -t u1 -v |
#   tr -Cs 0123456789 '[\n*]' |
#   grep . |
#   awk -v '
#     {printf"cmd\"%d\"=\"%c\";",$0,tolower(sprintf("%c",$0));}
#   '
# )"
awk -v dot=46 '
BEGIN{
   # valid command table.
   cmd["112"]="p";cmd["80"]="p";
   cmd["111"]="o";cmd["79"]="o";
   cmd["110"]="n";cmd["78"]="n";
   cmd["105"]="i";cmd["73"]="i";
   cmd["95"] ="_";
   cmd["99"] ="c";cmd["67"]="c";
   cmd["115"]="s";cmd["83"]="s";
   cmd["118"]="v";cmd["86"]="v";
   cmd["102"]="f";cmd["70"]="f";
   cmd["101"]="e";cmd["69"]="e";
   cmd["114"]="r";cmd["82"]="r";
   cmd["119"]="w";cmd["87"]="w";
   cmd["120"]="x";cmd["88"]="x";
   cmd["121"]="y";cmd["89"]="y";
   cmd["122"]="z";cmd["90"]="z";
   cmd["97"] ="a";cmd["65"]="a";
   cmd["116"]="t";cmd["84"]="t";
   cmd["109"]="m";cmd["77"]="m";
   cmd["100"]="d";cmd["68"]="d";
   cmd["43"] ="+";
   cmd["45"] ="-";
   cmd["33"] ="!";
   cmd["36"] ="$";
   cmd["37"] ="%";
   # stores literal items.
   split("",stack,":");
   # level for stack. items in 0<=i<=stack-1.
   level=0;
}
{
   stack[level]=$0;
   level+=1;
   if(level>=2){
      first=stack[level-2];
      second=stack[level-1];
      if(first==dot&&second in cmd){
         level-=2;
         if(level>0){
            printf"l";
            for(i=level-1;i>=0;i--)
               printf" " stack[i];
            print"";
            level=0;
         }
         print cmd[second];
      }
   }
}
END{
   if(level>0){
      printf"l";
      for(i=level-1;i>=0;i--)
         printf" " stack[i];
      print"";
   }
}' |
# check syntax
# also opt1. remove deadcode (from .d to EOF or matching .a)
awk -v me="${0##*/}" -v optlv="$optlv" '
BEGIN{
   nest=0;
   while(getline>0){
      nest+=/[wxyz]/-/a/;
      if(nest<0){
         print me ": Syntax error: .a unexpected before .[wxyz]" | "cat 1>&2";
         exit 1;
      }
      # add a hint please
      # wxyz: begin of what level?
      # a: end of what level?
      if(/[wxyza]/) $0=$0 " @ " (/a/?nest+1:nest);
      print $0;
      # opt1: remove deadcode
      if(optlv<=0) continue;
      if(/d/&&nest==0) exit 0;
      if(/d/){
         unignore_on=nest-1;
         while(nest>unignore_on){
            if(getline<=0){
               print me ": Syntax error: .[wxyz] command without matching .a" | "cat 1>&2";
               exit 1;
            }
            nest+=/[wxyz]/-/a/;
         }
         print "a @ " nest+1;
      }
   }
   if(nest>0){
      print me ": Syntax error: .[wxyz] command without matching .a" | "cat 1>&2";
      exit 1;
   }
   exit 0;
}'
)" # check syntax and remove deadcode end

# opt2. remove commands that would be NOP when not enough items.
case "$(( optlv >= 2 ))" in (1)
assembly="$(

printf %s\\n "$assembly" |
# remove poncsvrt+-!$% if surely empty, 
# because they are NOP in such case
# obtw +-!$% requires >=2 items
awk \
  -v assumed_size=0 \
  -v surely="$(
    case "$1" in (filename)
      echo 1
    ;;(content)
      echo 0
    ;;esac
  )" \
  -v heap_used=0 '
/[poncsvrt+!$%-]/&&surely&&assumed_size==0{
   # remove here
   next;
}
/[+!$%-]/&&surely&&assumed_size==1{
   # remove here
   next;
}
/l/&&surely{
   assumed_size+=NF-1;
}
/p/{
   assumed_size=0;
   surely=1;
}
/[ons]/&&surely&&assumed_size>=1{
   assumed_size-=1;
}
/[i_]/&&surely{
   if(surely) assumed_size+=1;
}
/c/&&surely&&assumed_size>=1{
   assumed_size+=1;
}
/[fewxyza]/{
   surely=0;
}
/t/&&surely&&assumed_size>=1{
   assumed_size-=1;
   heap_used=1;
}
/m/&&surely&&heap_used{
   assumed_size+=1;
}
/[+!$%-]/&&surely&&assumed_size>=2{
   assumed_size-=1;
}
1;
'
)" # remove poncsvrt+-!$% if surely empty end

;;esac # opt2 end

# opt3. calculate constant expr.
case "$(( optlv >= 3 ))" in (1)

assembly="$(

printf %s\\n "$assembly" |
# calculate const expr
# they are literals with cs+-!$%
awk -v me="${0##*/}" '
BEGIN{
   # plz remember
   split("",prog,":");
   # prog size
   i=0;
}
{
   # store current code
   prog[i]=$0; i+=1;
   
   prev=prog[i-2];
}
prev~"l"&&/l/{
   # join two literal commands
   prog[i-2]=prev " " substr($0,3);
   delete prog[i-=1];
   next;
}
prev~"^l [^ ]+"&&/c/{
   sub("[^ ]+$","& &",prog[i-2]);
   delete prog[i-=1];
   next;
}
prev~"^l [^ ]+$"&&/s/{
   # just discard it when single literal
   i-=2;
   delete prog[i];
   delete prog[i+1];
   next;
}
prev~"l"&&/s/{
   sub(" [^ ]+$","",prog[i-2]);
   delete prog[i-=1];
   next;
}
prev~"^l [^ ]+ [^ ]+"&&/[+!$%-]/{
   # arithmetic requires >=2 items
   # prevent zero-division
   if(/[$%]/&&prev~"( 0| 0 [^ ]+)$") next;
   
   # extract two nums on top
   op=$0; $0=prev;
   x=$NF; y=$(NF-1);
   sub(" [^ ]+ [^ ]+$","",prev);
   $0=op;
   # make it sure: x>=y
   if(x<=y){
      _x=x; x=y; y=_x;
   }
   
   # finally
   if(/\+/) prog[i-2]=prev " " (x+y);
   if(/-/) prog[i-2]=prev " " (x-y);
   if(/!/) prog[i-2]=prev " " (x*y);
   if(/\$/) prog[i-2]=prev " " int(x/y);
   if(/%/) prog[i-2]=prev " " int(x%y);
   delete prog[i-=1];
   next;
}
END{
   for(j=0;j<i;j++)
      print prog[j];
}
'
)" # constant reduction end

;;esac # opt3 end

# now optimization is done.

# this is to determine what functions are required.
printf %s\\n "$assembly" |
cut -c 1 | sort | uniq | tr -d \\n |
case "$1" in (fname) tr -d d ;;(content) cat ;;esac |
grep . | sed 's/^/# /'

# remove hints for wxyza
assembly="$(
printf %s\\n "$assembly" |
sed 's/ @ .*$//'
)"

# finally translate to awk
printf %s\\n "$assembly" |
# remove if empty
grep . |
sed -n '
# l has some arguments
# P(char) is push.
/^l /{
  s///
  s/[^ ]*/P(&);/g
  s/ //g
  p
  b
}
# they are simple; to same named function.
/[poni_csvfertm]/s//&();/p
t
/[wxyz]/s//while(&()){/p
t
# no a function
/a/s//}/p
t
# d needs some branching
'"$(
case "$1" in (fname)
  echo '/d/s//exit(0);/p'
;;(content)
  echo '/d/s//d();return;/p'
;;esac
)"'
t
# arithmetics because function name restrictions
/+/s//add();/p
t
/-/s//sbt();/p
t
/!/s//mul();/p
t
/\$/s//div();/p
t
/%/s//mod();/p
t
# should not reach here
s/.*/WTF("&");/p
' |
(
case "$1" in (fname)
  printf 'BEGIN{S[k=0]=0;split("",h,":");'
  cat
  printf '}'
;;(content)
  # B local variable. just an index.
  printf 'function e(B){k++;S[k]=S[k-1];for(B=0;B<S[k];B++)S[k,B]=S[k-1,B];'
  cat
  printf 'd();}'
;;esac
) |
tr -d \\n

} # compile()

# main I think

: prelude && {
#
# k>=0. global. id of VM.
# S. global stack. [k] or [k,i] where
#   S[k] stores size
#   S[k,i] stores items. 0<=i<S[k].
#
# h[k]. global heap. empty or integer
#
# P(char) is push.
# E() returns if empty.
# J() returns if size >= 2.
# K() returns size.
# T() is top. stupid.
# X() is pop, with return of the value. stupid.
#
# u(char) is putchar().
# G() is getchar().
#   un is global unget buffer.
# U(char) is ungetc().
# H() is shift input buffer. for interactive mode.
#
# A(str) is abort().
#
# also sorry for abuse of one-char local vars;
# i want to make final code shorter, and sorry for
# random var names; to avoid sharing name with functions.
# GAWK is the good example that same namespace.
#
awkscript='BEGIN{if(seed~".")srand(seed);}
function P(D){S[k,K()]=D;S[k]++;}
function E(){return K()==0;}
function J(){return K()>1;}
function K(){return S[k];}
function T(){return S[k,K()-1];}
function X(R){R=T();S[k]--;return R;}
function u(C){if(!otty)print C;else if(-1<C&&C<256)system(sprintf("printf \\\\%o",C));}
function G(R){if(un~/./){R=un;un="";return R;}if(!itty)return getline>0?$0:-1;if(NF!=0)return H();Z="cat|od -An -vtu1|tr -Cs 0123456789 \"[ *]\"|sed \"s/^ *//;s/ *$//\"|grep ^";R=(Z|getline>0)?H():-1;close(Z);return R;}
function H(R){R=$1;sub("^[0-9]+$","");sub("^[0-9]+ ","");return R;}
function U(C){un=C;}
function A(M){print me ": " M|"cat 1>&2";exit 1;}'
}

: 'generate main routine' && {
fnameprog="$(printf %s "${1##*/}" | compile)"
awkscript="$awkscript$(printf %s "$fnameprog" | grep -v '#')" 
reqfn="$(
  printf %s "$fnameprog" |
  grep '#' |
  tr -d '# \n'
)"
}

: plz check iff e and f are required && {

test -f "$1" || test -c "$1" || test -p "$1" && {
  test -r "$1" || {
    printf %s\\n "${0##*/}: $1: Permission denied"
    exit 1
  }
}

}

: e cmd to generate subroutine &&
case "$reqfn" in (*e*)

contprog="$(cat "$1" | compile content)"
awkscript="$awkscript$(printf %s "$contprog" | grep -v '#')" 
printf %s\\n "$contprog";
reqfn="$reqfn$(
  printf %s "$contprog" |
  grep '#' |
  tr -d '# \n'
)"

;;esac

: f cmd &&
case "$reqfn" in (*f*)

awkscript="${awkscript}function f(){$(
  cat "$1" |
  od -A n -t u1 -v |
  tr -Cs 0123456789 '[\n*]' |
  grep . |
  awk '$0=NR " " $0;' |
  sort -k 1nr,1 |
  sed 's/^[0-9]* \(.*\)$/P(\1);/'
)}"

;;esac

: define functions required by commands && {
awkscript="$awkscript$(
echo "$reqfn" | fold -w 1 | sort | uniq |
sed -n '
# skip l; P() is enough
/p/c\
function p(){while(!E())u(X());}
/o/c\
function o(){if(!E())u(X());}
# n(Iterator,q:popped value,Digit,l: digits of q)
/n/c\
function n(I,q,D,l){if(!E()){q=X();l=length(q);for(I=1;I<=l;I++)u((D=substr(q,I,1))~"[0-9]"?D+48:45);}}
/i/c\
function i(){P(G());}
# _(error Message,Char to get,Z: sign, Y: digits)
/_/c\
function _(M,C,Z,Y){M="._: Not a decimal integer input";C=G();Z=1;for(;;){if(47<C&&C<58)break;if(C~"^4[35]$"){Z=44-C;C=G();break;}if((8<C&&C<14)+(C==32)){C=G();continue;}A(M);}if((C<48)+(C>57))A(M);for(;47<C&&C<58;C=G())Y=Y (C-48);U(C);P(Z*Y);}
/c/c\
function c(){if(!E())P(T());}
/s/c\
function s(){if(!E())X();}
# v(Iterator,j: iterator,V: temp)
/v/c\
function v(I,j,V){I=0;for(j=K()-1;I<j;){V=S[k,I];S[k,I++]=S[k,j];S[k,j--]=V;}}
# skip f; defined already
# skip e; is defined on: compile content
/r/c\
function r(){if(!E()){if(rposonly&&T()<=0)A(".r: Undefined against non-positive item");P(int(rand()*X()));}}
/w/c\
function w(){return E()||(X()!=0);}
/x/c\
function x(Q,q){if(!J())return 1;Q=X();q=X();return Q<q;}
/y/c\
function y(Q,q){if(!J())return 1;Q=X();q=X();return Q>q;}
/z/c\
function z(){return((!J())||(X()!=X()));}
# skip a; no function needed
/t/c\
function t(){if(!E())h[k]=X();}
/m/c\
function m(){if(k in h)P(h[k]);}
/d/c\
function d(I,j){if(k in h)delete h[k];k--;I=0;for(j=S[k];I<S[k+1];(I++)*(j++)*(S[k]++))S[k,j]=S[k+1,I];}
/+/c\
function add(){if(J())P(X()+X());}
/-/c\
function sbt(I){if(J()){P((I=X()-X())<0?-I:I);}}
/!/c\
function mul(){if(J())P(X()*X());}
/\$/c\
function div(q,l){if(J()){if((q=X())*(l=X())==0)A(".$: Zero-division");P(int(q>l?q/l:l/q))}}
/%/c\
function mod(q,l){if(J()){if((q=X())*(l=X())==0)A(".%: Zero-division");P(int(q>l?q%l:l%q))}}
')" # awkscript

} # define required functions

# finally we are executing awk script.

#
# required vars for awk.
#   me. program name.
#
#   otty. 1 iff stdout is terminal.
#         1. output by myself.
#         0. leave final output to external.
#
#   itty. 1 iff stdin is terminal.
#         1. call getchar()-like by myself.
#
#         0. let external to parse input.
#
#   seed. for srand().
#
#   rposonly. .r command option.
#             1. let it be defined for >0 only.
#             0. .r does "push int(rand()*pop())" for every value.

seed=
case "$reqfn" in (*r*)
  seed="$(
    test -c /dev/urandom&&test -r /dev/urandom &&
    od -A n -v -t d4 -N4 /dev/urandom ||
    (ps -Ao pid,etime,pcpu,vsz;date) |
    od -A n -v -t u4 |
    tr -Cs 0123456789 '[\n*]' |
    grep . | tail -n 42 |
    sed 's/.*\(.\{8\}\)$/\1/' |
    awk -v a=-2147483648 '{a+=$0;}END{print a;}'
  )"
;;esac

case "$reqfn" in (*[i_]*)
  # XXX. captive way of inputting?
  # WHAT. XXX. is it impossible without TEMPORARY FILE FOR SIGNAL HANDLING?
  # what. when filename is XX.z.d.a.i and input is from od, then it terminates automatically.
  # But if .iXX.z.d.a.i, you need to enter EOF by yourself.
  if ! : test -t 0; then
    awk -v seed="$seed" -v otty=1 -v itty=1 "$awkscript"
  else
    # input here
    od -A n -v -t u1 | tr -Cs 0123456789 '[\n*]' | grep . |
    # actual interpreter here
    awk -v seed="$seed" -v otty=0 -v itty=0 "$awkscript" |
    # outputter
    awk -v q="'" -v ORS='' -v sep='' '
      BEGIN{for(i=0;i<256;i++)c[i]=sprintf("\\%o",i);}
      # 4*50=200. 200+7+1+2=210.
      NR%50==1{print sep "printf " q;sep=q "\n";}
      {print c[$0];}
      END{if(sep)print q "\n";}
    ' |
    # i hate xargs.
    sh -s
  fi
;;(*)
  # actual interpreter here
  awk -v seed="$seed" -v otty=0 "$awkscript" |
  # outputter
  awk -v q="'" -v ORS='' -v sep='' '
    BEGIN{for(i=0;i<256;i++)c[i]=sprintf("\\%o",i);}
    # 4*50=200. 200+7+1+2=210.
    NR%50==1{print sep "printf " q;sep=q "\n";}
    {print c[$0];}
    END{if(sep)print sep;}
  ' |
  # i hate xargs.
  sh -s
;;esac
